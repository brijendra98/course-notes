# CS241 - LEC005: MIPS Assembler
Assembly Language ---> (cs241.binasm) ---> machine language (binary)

- read input string
  - make sense out of it
- translate into binary
### Stages
- Analysis: Making sense of the input string
  - understanding the meaning/intent
- Synthesis: Output equivalent machine binary instruction

**Analysis:** multiple steps
1. Tokenize / Scanning / Lexical Analysis
    - Convert input string into a sequence of Tokens (Tokenization is already done for you for A3)
  ```
class Token {
	std::string Kind; // the type of token (ID/REG/COMMA)
	std::string lexeme; // the actual input characters making up this token
	public:
	---------------
	---------------
	---------------
}
``` 
Scanner produces a vector<vector< Token >>

2. Parse: Make sense of what each line means
	- Simple to do for MIPS assembly.
	- Do it in an ad hoc way
	  - Depending on the type of instruction, check syntax
	  ```
	  if ( token[0].getKind() == "ID" 
						  token[0].getLexeme() == "add") {
						  }
	  ```
	  **Possible errors: **
	  - Incorrect no. of registers
	  - Incorrect no. of commas
	  - Incorrect range for registers
	  - Unexpected ID/NUM

Instead of looking for errors, look for what is correct and everything else will be wrong. Much easier.

### Synthesis
1. Produce within the assembler the 32 bits representing the instruction
2. Output these bits.
	How to deal with labels?
	Use of a label in bne/beq has to be converted to an instruction offset
	**Algorithm:-**
	- initialize PC <--- 0
	- increment PC by 4 for each instruction of .word when a label is defined
	- store the "lexeme"
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTk3NzI3ODYxNywxNjE4MTM3NjgxLC02Nz
Y1MzA3ODcsNzg3NDc5NDg4LC02NTUzMTQ3NjAsMTIzNzI4NzA5
MywtMzgzMTAxNDMyLC01NDU4MDA4Nl19
-->